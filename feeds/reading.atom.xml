<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mozillazg's Blog</title><link href="https://mozillazg.com/" rel="alternate"></link><link href="https://mozillazg.com/feeds/reading.atom.xml" rel="self"></link><id>https://mozillazg.com/</id><updated>2015-10-29T00:00:00+00:00</updated><entry><title>《Web 全栈工程师的自我修养》读书笔记</title><link href="https://mozillazg.com/2015/10/web-full-stack-engineer-note-1.html" rel="alternate"></link><updated>2015-10-29T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-10-29:2015/10/web-full-stack-engineer-note-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26598045/"&gt;&lt;img alt="Web 全栈工程师的自我修养" src="/static/images/reading/web-full-stack-programmer.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;什么是全栈工程师&lt;/h2&gt;
&lt;p&gt;关于全栈工程师的定义，Quora 上得票最高的回答是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全栈工程师是指，一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web 栈、或者原生应用程序栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流水线开发流程“各司其职”的弊端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工程师职责不清导致效率低下&lt;/li&gt;
&lt;li&gt;工程师缺乏主人感导致产品质量差&lt;/li&gt;
&lt;li&gt;工程师缺乏全局的视野影响个人成长&lt;/li&gt;
&lt;li&gt;更多角色导致项目效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;全栈工程师首先要“一专多长”。一专多长的意思是，工程师首先有一个专精的方向，在这个方向上足够精通后（高级工程师级别），以此为突破点去学习更多的知识，增加自己的长处。如果还没有获得某个方向上足够深入的理解，就不要囫囵吞枣地去学习其他领域的知识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;勿在浮沙筑高台，“全栈”是一个长期积累的过程，是专精型工程师
在不断解决问题的过程中积累知识和经验所形成的能力，而不是一蹴而就的过程。&lt;/p&gt;
&lt;p&gt;解决问题，而不是醉心技术。如果新计划不是你擅长的，怎么办？您应该马上开始学习新的技术，这就是我说的关注问题，而不是醉心技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《黑客与画家》&lt;/li&gt;
&lt;li&gt;《专业主义》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如何成为全栈工程师&lt;/h2&gt;
&lt;h3&gt;“先精后广，一专多长”&lt;/h3&gt;
&lt;p&gt;建议初学者学习全栈技能的时候，先在一个特定的方向上有比较深入的钻研，然后再将学习目标逐渐推广开来。&lt;/p&gt;
&lt;p&gt;作为一个求职者，无论是毕业生还是社会招聘，仅仅满足招聘要求是不够的。您需要在招聘要求的方向上 200% 的能力来得到这个职位。&lt;/p&gt;
&lt;h3&gt;围绕商业目标&lt;/h3&gt;
&lt;p&gt;老板雇用一个员工，不是因为他能写程序，而是因为他能帮助自己赚钱。
一切都要围绕商业目标来进行，包括您做的项目、您的汇报方式，以及您在学习新技能时进行的取舍。&lt;/p&gt;
&lt;p&gt;记住，当您只有一把锤子，您看什么都是钉子。
而如果您痴迷于工具，反而看不到问题的所在。因此，要先看看
有哪些问题需要解决，然后再补充您的工具箱。
永远从商业目标的角度来决定学习哪个东西，而不是纯粹为了锻炼
技术能力而去学习。&lt;/p&gt;
&lt;h3&gt;关注用户体验&lt;/h3&gt;
&lt;p&gt;老板雇用您不是因为您能写代码（或者做工具），而是因为您能帮他赚钱。所以您要用一切办法，去优化流程解决痛点，
做工具是一个可选的方法，但不应该是您的第一个想法，更不是唯一的方法。假使真的是做一个工具，最终汇报邮件的时候，不要以
“我做了一个工具。。。”开头，而应该以“我发现了一个问题。。。”开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《重来：更为简单有效的商业思维》&lt;/li&gt;
&lt;li&gt;《精益创业》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从学生到工程师&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《编程之美：微软技术面试心得》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;野生程序员的故事&lt;/h2&gt;
&lt;p&gt;野生程序员容易陷入样样不精通的窘境。&lt;/p&gt;
&lt;h3&gt;大公司还是创业公司&lt;/h3&gt;
&lt;p&gt;大公司能给您的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;较小的风险&lt;/li&gt;
&lt;li&gt;技术最佳实践&lt;/li&gt;
&lt;li&gt;垂直专精的技能&lt;/li&gt;
&lt;li&gt;服务海量用户的经验&lt;/li&gt;
&lt;li&gt;软技能&lt;/li&gt;
&lt;li&gt;人脉&lt;/li&gt;
&lt;li&gt;心态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者个人建议是，从毕业生自己前途发展的角度来看，
先加入一家上市大公司是个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《打造 Facebook》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;工程师事业指南&lt;/h2&gt;
&lt;h3&gt;那个什么都懂的家伙&lt;/h3&gt;
&lt;p&gt;软件工程师事业指南告诉您，最核心的 3 个词就是技术、成长和声望。
技术是您的武器，成长就是好好打磨武器，而声望是
您一生的积累。&lt;/p&gt;
&lt;h3&gt;积累作品集&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《您就是极客：软件开发人员生存指南》&lt;/li&gt;
&lt;li&gt;《代码整洁之道》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全栈工程师眼中的 HTTP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;尽量减少同一域下的 HTTP 请求数&lt;/strong&gt;
浏览器常常限定了对同一域名发起的并发连接数的上限。
IE 6/7 和 Firefox 2 的设计规则是，同时只能对一个
域名发起两个并发连接。新版本的各种浏览器普遍把这一上限
设定为 4 至 8 个。&lt;/p&gt;
&lt;p&gt;把静态资源放在非主域名下，这种做法除了可以增加浏览器并发，
还有一个好处是，减少 HTTP 请求中携带的不必要的 cookie 数据。&lt;/p&gt;
&lt;p&gt;除此之外，前端工程师经常做的优化是合并同一域名下
的资源，比如把多个 css 合并为一个 css, 或者将图片组合成 css 拼图。&lt;/p&gt;
&lt;p&gt;还有一些优化建议是省掉不必要的 HTTP 请求，比如内嵌小型 css, 内嵌小型 javascript,
设置缓存，以及减少重定向。&lt;/p&gt;
&lt;h2&gt;高性能网站的关键：缓存&lt;/h2&gt;
&lt;p&gt;服务器缓存&lt;/p&gt;
&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《网站性能监测与优化》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;大前端&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;知识体系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对浏览器兼容性的了解&lt;/li&gt;
&lt;li&gt;对 HTML/CSS/JavaScript 语法和原理的理解&lt;/li&gt;
&lt;li&gt;对编辑器和插件的熟悉程度&lt;/li&gt;
&lt;li&gt;对调试工具的了解程度&lt;/li&gt;
&lt;li&gt;对版本管理软件的熟悉和应用经验&lt;/li&gt;
&lt;li&gt;对前端库/框架的使用。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准/规范&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对代码质量，代码规范的理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;对 JavaSript 单元测试的熟悉。&lt;/li&gt;
&lt;li&gt;对性能优化的应用和理解。&lt;/li&gt;
&lt;li&gt;对 SEO 的应用和理解。&lt;/li&gt;
&lt;li&gt;代码部署。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动 Web。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;对自动化测试的理解&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;向移动端转型&lt;/h2&gt;
&lt;h3&gt;有哪些方向&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;iOS 原生 App&lt;/li&gt;
&lt;li&gt;Android 原生 App&lt;/li&gt;
&lt;li&gt;Windows Phone 原生 App&lt;/li&gt;
&lt;li&gt;Web App&lt;/li&gt;
&lt;li&gt;混合模式 App(Hybrid App)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Getting Real》&lt;/li&gt;
&lt;li&gt;《从 0 到 1：开启商业与未来的秘密》&lt;/li&gt;
&lt;li&gt;《Building iPhone Apps with HTML, CSS, and JavaScript》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;持续集成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;版本控制最佳实践&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼓励频繁地提交&lt;/li&gt;
&lt;li&gt;确定分支流程&lt;/li&gt;
&lt;li&gt;定义主干原则，并且坚守它&lt;/li&gt;
&lt;li&gt;不要把逻辑的修改和代码格式化操作混在一起&lt;/li&gt;
&lt;li&gt;不相干的代码分开提交&lt;/li&gt;
&lt;li&gt;保持工作代码库的“干净”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;包管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm&lt;/li&gt;
&lt;li&gt;bower&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Pro Git book》&lt;/li&gt;
&lt;li&gt;《Git 版本控制管理》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;理解编程语言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通用用途语言 VS 特定领域语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特定领域语言（Domain Specific Language, DSL）。
DSL 的目的是解决特定领域的问题。&lt;/p&gt;
&lt;p&gt;如果您是一个以解决问题为目标的全栈工程师，我建议您在考虑
发明一个 DSL 之前先考虑以下方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量使用您熟悉的通用语言来解决问题，比如 Python, Java 或 C++.&lt;/li&gt;
&lt;li&gt;优化您的方案，提炼出一种真正精简、优雅的扩展库。&lt;/li&gt;
&lt;li&gt;开源您的扩展库，根据其他人的贡献来继续优化解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《代码大全》&lt;/li&gt;
&lt;li&gt;《代码的未来》&lt;/li&gt;
&lt;li&gt;《禅与摩托车维修的艺术》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全栈游乐场&lt;/h2&gt;
&lt;p&gt;就是说了需要有一个自己的 VPS, VPS 可以让你对网站的全貌有所了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《鸟哥的 Linux 私房菜：基础学习篇》&lt;/li&gt;
&lt;li&gt;《只是为了好玩：Linux 之父林纳斯自传》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;软件设计方法&lt;/h2&gt;
&lt;h3&gt;设计模式&lt;/h3&gt;
&lt;p&gt;设计模式的关注点在于以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效编写代码&lt;/li&gt;
&lt;li&gt;高可复用性&lt;/li&gt;
&lt;li&gt;抽象带来的可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;《设计模式》一书中作者列出了 23 种软件设计模式，分为三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式，就是用来创建对象的模式，它对实例化的过程进行了抽象。创建型模式帮助一个系统独立于如何创建、组合和表示它的那些对象。&lt;ul&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;工厂方法&lt;/li&gt;
&lt;li&gt;抽象工厂&lt;/li&gt;
&lt;li&gt;建造模型&lt;/li&gt;
&lt;li&gt;原型模式&lt;/li&gt;
&lt;li&gt;对象池模式&lt;/li&gt;
&lt;li&gt;多例模式等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结构型模式，主要解决类、对象、模块之间的耦合关系。&lt;ul&gt;
&lt;li&gt;适配器模式(Adapter)&lt;/li&gt;
&lt;li&gt;桥接模式&lt;/li&gt;
&lt;li&gt;组合模式&lt;/li&gt;
&lt;li&gt;装饰模式&lt;/li&gt;
&lt;li&gt;外观模式&lt;/li&gt;
&lt;li&gt;享元模式&lt;/li&gt;
&lt;li&gt;代理模式等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行为模式，用来识别对象之间的常用交流模式并加以实现。&lt;ul&gt;
&lt;li&gt;观察者模式（发布订阅模式）&lt;/li&gt;
&lt;li&gt;黑板&lt;/li&gt;
&lt;li&gt;责任链&lt;/li&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;li&gt;解释器&lt;/li&gt;
&lt;li&gt;迭代器&lt;/li&gt;
&lt;li&gt;中介者&lt;/li&gt;
&lt;li&gt;备忘录&lt;/li&gt;
&lt;li&gt;空对象&lt;/li&gt;
&lt;li&gt;模板方法&lt;/li&gt;
&lt;li&gt;访问者等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;架构模式&lt;/h3&gt;
&lt;p&gt;比如：MVC&lt;/p&gt;
&lt;h3&gt;设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DRY，是 "Don't Repeat Yourself" 的缩写，在一个系统里，对于任何数据或变量，都应该配置在有且只有一个地方，其他地方都应该引用这里的数据。&lt;/li&gt;
&lt;li&gt;惯例优于设置，开发人员仅需要规定应用中不符合约定的部分。&lt;/li&gt;
&lt;li&gt;KISS 原则，是 "Keep it simple, stupid" 的缩写，意思是说软件设计当中应该注重简约的原则。&lt;/li&gt;
&lt;li&gt;最少知道原则，它是“松耦合原则”的一个具体实例，是指在面向对象编程中，每一个软件单元应该尽可能少地与其他单元发生作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《设计模式：可复用面向对象软件的基础》&lt;/li&gt;
&lt;li&gt;《JavaScript 设计模式》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;高效工程师&lt;/h2&gt;
&lt;h3&gt;提速 100 倍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阅读英文资料&lt;/li&gt;
&lt;li&gt;时间管理四象限&lt;ul&gt;
&lt;li&gt;既紧急又重要的（立即执行）&lt;/li&gt;
&lt;li&gt;紧急不重要（他人代劳）&lt;/li&gt;
&lt;li&gt;重要不紧急（制定计划，建议工程师把 80% 的工作投入到该象限中，避免“瞎忙”）&lt;/li&gt;
&lt;li&gt;不紧急不重要（对它所不）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消除重复工作&lt;/li&gt;
&lt;li&gt;给自己留出不被打扰的时间&lt;/li&gt;
&lt;li&gt;番茄工作法&lt;/li&gt;
&lt;li&gt;跨界思考&lt;/li&gt;
&lt;li&gt;纸上头脑风暴&lt;/li&gt;
&lt;li&gt;使用版本控制工具和构建系统&lt;/li&gt;
&lt;li&gt;不要加班&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《软件随想录：程序员部落酋长 Joel 谈软件》&lt;/li&gt;
&lt;li&gt;《卓有成效的程序员》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;学习设计&lt;/h2&gt;
&lt;h3&gt;设计基础&lt;/h3&gt;
&lt;p&gt;设计的四大基本理论是：亲密性，对齐，重复，对比。&lt;/p&gt;
&lt;p&gt;设计工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Axure&lt;/li&gt;
&lt;li&gt;Sketch&lt;/li&gt;
&lt;li&gt;Quartz Composer&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《响应式 Web 设计全流程解析》&lt;/li&gt;
&lt;li&gt;《写给大家看的设计书（第 3 版）》&lt;/li&gt;
&lt;li&gt;《写给大家看的设计书：实例与创意》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全栈思维&lt;/h2&gt;
&lt;h3&gt;有兴趣就够了吗？&lt;/h3&gt;
&lt;p&gt;扯一些理由（特别是私人的理由）根本就是不专业的态度。
不要给自己没能完成的事情找任何理由，而要以诚恳的态度说明当前进度，以及未来是否能如期完成目标，如果不能，就直接说出来。&lt;/p&gt;
&lt;p&gt;在职场中，我们评估一个人并不是根据他的能力，而是他能
承担的责任。同样，我们最终评估一个人是否应该升职加薪，
不是看他的能力，也不是看他投入的时间，更不是看兴趣，
只是看他的责任。&lt;/p&gt;
&lt;h3&gt;学一点管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;好的管理者能让平凡的员工做不平凡的事&lt;/li&gt;
&lt;li&gt;根据员工特质来授权&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;沟通： 被忽视的竞争力&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《卓有成效的管理者》&lt;/li&gt;
&lt;li&gt;《麦肯锡教我的写作武器》&lt;/li&gt;
&lt;li&gt;《金字塔原理》&lt;/li&gt;
&lt;li&gt;《安静：内向性格的竞争力》&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Web 全栈工程师的自我修养"></category></entry><entry><title>《High Performance Django》阅读笔记（三）</title><link href="https://mozillazg.com/2015/09/high-performance-django-note-3.html" rel="alternate"></link><updated>2015-09-28T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-09-28:2015/09/high-performance-django-note-3.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26359018/"&gt;&lt;img alt="" src="/static/images/reading/s28041145.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第四章：预备&lt;/h2&gt;
&lt;h3&gt;使用 Jmeter 进行负载测试&lt;/h3&gt;
&lt;p&gt;这一部分主要讲解了 Jmeter 的各种是否方法及配置。&lt;/p&gt;
&lt;h3&gt;启动计划&lt;/h3&gt;
&lt;p&gt;启动的时候有些东西需要考虑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用负载均衡器在新的和旧的之间分流&lt;/li&gt;
&lt;li&gt;使用“dark launch”，这样用户就不会感觉到他们访问的是新的服务器&lt;/li&gt;
&lt;li&gt;使用代理功能分一部分流量到新的服务器&lt;/li&gt;
&lt;li&gt;使用特性标志来发布一个新的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送流量到一个新的没有缓存的服务器可能会导致临时的高负载
从而在缓存热和起来前击垮你的服务器。预热你的缓存可以解决这个问题。一个比较简单的办法是使用一个脚本在有真实请求前去抓取你的网站上的热门 URLs。&lt;/p&gt;
&lt;p&gt;不要在一天的最后时间段或周五的时候升启动，除非你想让你的
整个团队在晚上或周末加班。
你应该在大家都在并且有几个小时或几天的时间来处理
启动过程中出现的问题时候启动，同时也要确保你的成员有时间休息。
如果你的网站访问量比较高的话，尝试在访问量比较低的时间段进行升级操作。&lt;/p&gt;
&lt;h3&gt;启动前的检查事项&lt;/h3&gt;
&lt;h4&gt;Django 配置项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DEBUG&lt;/code&gt; 和 &lt;code&gt;TEMPLATE_DEBUG&lt;/code&gt; 都设为 &lt;code&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt; 是个非常大的随机字符串并且保密&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; 包含了访问者可能会使用的有效域名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEMPLATE_LOADERS&lt;/code&gt;: Cached template loader 已启用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SESSION_ENGINE&lt;/code&gt; 比默认设置更快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CACHES&lt;/code&gt;: 使用 Memcached 或 Redis 后端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MEDIA_ROOT&lt;/code&gt; 和 &lt;code&gt;MEDIA_URL&lt;/code&gt; 接受并显示文件上传&lt;/li&gt;
&lt;li&gt;管理员账户被限制并且有一个强壮的密码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;部署&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过点击各种页面和链接的方式来确认网站是否按预期的结果
  工作（没有挂掉的图片和链接）&lt;/li&gt;
&lt;li&gt;Django 日志是否正常工作&lt;/li&gt;
&lt;li&gt;监控平台是否接收到数据。确保你能看到整个技术栈中各级
  的错误信息。&lt;/li&gt;
&lt;li&gt;错误被汇报并且触发了通知&lt;/li&gt;
&lt;li&gt;第三方服务能够接收到数据（支付，分析等等）&lt;/li&gt;
&lt;li&gt;从你的应用服务和 Celery workers 中发出邮件的功能
  能够正常运行&lt;/li&gt;
&lt;li&gt;自定义的错误页面（400，500）已经在各个级别中被设置（负载均衡器，web 加速器，Django）&lt;/li&gt;
&lt;li&gt;Django admin 没法通过 /admin/ 公开访问&lt;/li&gt;
&lt;li&gt;SSL 证书有效并且设置是安全的。&lt;/li&gt;
&lt;li&gt;Django-secure 的 &lt;code&gt;manage.py checksecure&lt;/code&gt; 运行起来没有错误输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基础设施&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;服务器和服务是安全的，已经锁好了大门&lt;/li&gt;
&lt;li&gt;有个简单，正式的程序用来部署新的代码&lt;/li&gt;
&lt;li&gt;你有一个可以在需要的时候快速水平扩展服务的计划&lt;/li&gt;
&lt;li&gt;DNS TTL 可以被修改为 5 分钟或更短的时间在需要更改的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五章 The Launch&lt;/h2&gt;
&lt;h3&gt;监控整个 Launch&lt;/h3&gt;
&lt;h4&gt;服务器资源&lt;/h4&gt;
&lt;p&gt;可以使用如下工具参考服务器资源使用情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;htop&lt;/li&gt;
&lt;li&gt;varnishstat&lt;/li&gt;
&lt;li&gt;varnishhist&lt;/li&gt;
&lt;li&gt;varnishtop&lt;/li&gt;
&lt;li&gt;varnishlop&lt;/li&gt;
&lt;li&gt;uwsgitop&lt;/li&gt;
&lt;li&gt;celery inspect&lt;/li&gt;
&lt;li&gt;celery events&lt;/li&gt;
&lt;li&gt;flower&lt;/li&gt;
&lt;li&gt;memcache-top&lt;/li&gt;
&lt;li&gt;pg_top&lt;/li&gt;
&lt;li&gt;pg_stat_statements&lt;/li&gt;
&lt;li&gt;pt-query-digest&lt;/li&gt;
&lt;li&gt;mytop&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;当灾难来临的时候&lt;/h3&gt;
&lt;h4&gt;应用服务器过载&lt;/h4&gt;
&lt;p&gt;最简单的办法就是通过增加服务器的方式进行水平扩展。
不过你需要注意这将导致你的数据库承受更大的压力，
可能会把数据库搞挂。&lt;/p&gt;
&lt;p&gt;当你通过增加服务器的方式把负载降低到可以接受的级别后，
你就需要使用你的低级别的工具来查看为什么会出现负载过高的
情况。你的 web 加速器端缓存命中率过低是一个需要考虑的因素。&lt;/p&gt;
&lt;h4&gt;数据库服务器过载&lt;/h4&gt;
&lt;p&gt;如果你的网站是 读多写少的话，可以通过增加 replica 的方式来简单解决响应时间问题。
同时也看看是否在数据库优化时遗漏某些可以优化的项。&lt;/p&gt;
&lt;h4&gt;应用和数据库服务器过载&lt;/h4&gt;
&lt;p&gt;你可以从自底向上优化你的数据库，减轻数据库的压力可以让你的应用拥有更高的性能。
你也可以通过优化你的 web 加速器从而减轻应用服务器的压力，进而减轻数据库服务器的压力。&lt;/p&gt;
&lt;h2&gt;前方的路&lt;/h2&gt;
&lt;p&gt;恭喜你的网站已经启动了！现在你需要确保它能够持续稳定的运行。在这个战争中你需要与下列事物做斗争：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的用户（流量增长）&lt;/li&gt;
&lt;li&gt;你的软件（一点点腐烂）&lt;/li&gt;
&lt;li&gt;你（错误的决定）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个没啥好惊讶的，最后两个可能会让你惊讶同时也是让你网站宕机的一些因素。&lt;/p&gt;
&lt;h3&gt;流量增长&lt;/h3&gt;
&lt;p&gt;正常情况下你的网站不应该在技术栈的任何层次占用 100% 的资源，一旦出现超过 70%（CPU,内存，磁盘等等）
的资源占用，那就说明某些地方需要优化了或者增加更多的资源。当流量突增的时候如果你有额外的资源的话就可以很好
的应对。&lt;/p&gt;
&lt;p&gt;有些时候的流量激增可能是商业上进行了某些吸引用户的活动，确保开发者知道这些商业活动，以便应对激增的流量。
一个好的主意是像刚启动时那样，大家在桌子上一起讨论分享这些商业信息。&lt;/p&gt;
&lt;h3&gt;一点点腐烂&lt;/h3&gt;
&lt;p&gt;由于高性能网站使用了很多不同的服务，所以需要保持这些服务打上了最新的安全补丁。
“如果没出现问题，就不要去修复它”是个非常危险的准则。&lt;/p&gt;
&lt;p&gt;跳过几个小版本是没什么问题的，但是不要落下太远，不然的话到时就会失去升级动力。
定期小步升级你的依赖（你的操作系统，主要的服务以及 Python 库）。&lt;/p&gt;
&lt;p&gt;作者的小贴士：&lt;/p&gt;
&lt;p&gt;当 review 升级的时候，我们通常不会使用最新的版本，一般最新版本也意味着有新的 bug ，我想
你不希望当小白鼠吧。给新版本几个月的成熟期。
升级到第一个稳定的版本或者你已经确保这个版本没什么大的问题了。&lt;/p&gt;
&lt;h3&gt;错误的决定&lt;/h3&gt;
&lt;h4&gt;意外的刷新了缓存&lt;/h4&gt;
&lt;p&gt;在流量特别高的时候重启缓存或 web 加速器可能会击垮你的网站。这个问题叫做 &lt;a href="http://en.wikipedia.org/wiki/Cache_stampede"&gt;dog-piling/cache stampede&lt;/a&gt;
所以尽量使用 reload 的方式来更新服务。对于使用 memcached/redis 的缓存可以通过给不同的缓存定义不同的 &lt;code&gt;KEY_PREFIX&lt;/code&gt;
的方式来实现逐个清理缓存（通过 &lt;code&gt;VERSION&lt;/code&gt;）而不是一下子删除所有缓存的功能。
如果一定要重启的话，进行选择在流量低的时候重启服务。&lt;/p&gt;
&lt;h4&gt;数据库锁表&lt;/h4&gt;
&lt;p&gt;数据库锁会临时阻塞主写操作，如果这个操作特别长的话就会成为一个问题。两个比较常见的长时间锁表的场景是： schema migration 和备份。&lt;/p&gt;
&lt;p&gt;在开发的时候， South 和内置的 migration 可以很方便的应用 Model 更改，
但是在生成环境下， migrate 操作可能会导致长时间的锁表现象，这个对你的用户来说就是个糟糕的消息了。
对于 &lt;code&gt;ADD COLUMN&lt;/code&gt; 操作，如果你使用的是 MySQL 数据库的话你需要留意一下这个，但是 PostgreSQL 很少会出现这个问题。&lt;/p&gt;
&lt;p&gt;无论你使用哪种数据库，migrations 都需要被 review 并且使用最近的线上数据的副本数据测试过后才能在生产环境使用。&lt;/p&gt;
&lt;p&gt;备份是另一个会导致长时间锁住数据库的操作。最好是在一个只读的 replica 上进行备份操作。&lt;/p&gt;
&lt;h4&gt;大量的缓存过期&lt;/h4&gt;
&lt;p&gt;跟刷新缓存差不多糟糕的事情就是有大量的缓存过期，这将导致数据库压力倍增。
如果你不是很确定的话，应该选择在流量比较低的时候进行部署操作，避免击垮你的站点。&lt;/p&gt;
&lt;h4&gt;昂贵的 admin 视图&lt;/h4&gt;
&lt;p&gt;构建一个未优化的 admin 视图会导致上千的数据库查询。
如果你正在使用一个查询缓存比如 johnny-cache, 每一次在 admin 中保存都将
导致与所在表相关的缓存都将失效。所以 admin 视图也需要像普通视图那样进行优化。&lt;/p&gt;
&lt;h4&gt;昂贵的后台任务&lt;/h4&gt;
&lt;p&gt;未优化，数据库依赖的任务会导致非预期的负载负担。所有应该像优化视图一样优化你的后台任务。&lt;/p&gt;
&lt;h4&gt;逐渐恶化&lt;/h4&gt;
&lt;p&gt;随着新功能的增加，网站的性能也在接受不同的考验，你需要随时关注性能问题。&lt;/p&gt;
&lt;p&gt;每次发布新版本的时候都关注一下性能的变化，如果响应时间变长了或者负载变高了，
立马去解决它。这样就不会出现在几个月的提交过去后再去查找问题所在的情况。&lt;/p&gt;
&lt;h4&gt;complexity creep&lt;/h4&gt;
&lt;p&gt;如果你按照前面所说的步骤做了的话，你已经做的非常好了。
随着你的网站的成长你可能会遇到各种各样的新问题，你可以很容易的就构建自己
独有的解决方法。
构建你自己的工具是件很有乐趣的事情，但是 &lt;a href="http://en.wikipedia.org/wiki/Not_invented_here"&gt;not invented here&lt;/a&gt; 对于长时间运行
的站点是非常危险的。你最好去学习如何让 Varnish 更高效而不是丢弃它转而使用你自己的工具。
这个决定衍生的代价是非常巨大的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;训练新的开发者需要更高的花费。你可以找到一名拥有使用一个比如 Varnish 这种服务经验的开发者，
  但是如果使用你自定义的方案的话，你需要训练每一位在门外徘徊的开发者。&lt;/li&gt;
&lt;li&gt;开发低级别的基础设施工具将会导致开发时间远离了你的核心产品。使用一个支持良好的开源服务，
  你的团队的开发者的效率会很高效。&lt;/li&gt;
&lt;li&gt;写你自己的软件代码不是一锤子买卖。所有的软件都需要不断的开发，测试，文档，等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最后的想法&lt;/h2&gt;
&lt;p&gt;现在你可以在看看那个老问题“Django doesn't scale”，你是怎么认为的呢？
如果只用 &lt;code&gt;manage.py runserver&lt;/code&gt;，使用 SQLite 在一个非常小的云服务器上跑
当然不会很快。&lt;/p&gt;
&lt;p&gt;让我们回到 2012 年，当 Instagram 只有3个的 Django 团队却支撑起了 1千4百多万的用户的时候，
他们在博客上是 &lt;a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-ofinstances-dozens-of"&gt;这么说的&lt;/a&gt; ：&lt;/p&gt;
&lt;p&gt;我们选择一个系统的核心宗旨是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持非常简单&lt;/li&gt;
&lt;li&gt;不要重复造轮子&lt;/li&gt;
&lt;li&gt;可能的话，使用久经考验的成熟的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们非常同意。因此，在你继续你的 Django 旅程的时候，不要忘了你在这里学到的东西。
简单是指导原则。&lt;/p&gt;</summary><category term="High Performance Django"></category><category term="Django"></category></entry><entry><title>《High Performance Django》阅读笔记（二）</title><link href="https://mozillazg.com/2015/09/high-performance-django-note-2.html" rel="alternate"></link><updated>2015-09-27T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-09-27:2015/09/high-performance-django-note-2.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26359018/"&gt;&lt;img alt="" src="/static/images/reading/s28041145.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第三章：The Deployment&lt;/h2&gt;
&lt;h3&gt;先决条件&lt;/h3&gt;
&lt;h4&gt;操作系统&lt;/h4&gt;
&lt;p&gt;作者推荐使用 Ubuntu。同时作者给出了选择其他操作系统时，需要考虑的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够很容易的就使用 Python 2.7+ 。有些操作系统要安装 2.7+ 版本的 Python 非常的麻烦，如果是这样的话你就要慎重考虑了。&lt;/li&gt;
&lt;li&gt;有长久的安全更新支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;配置管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Chef, Puppet, Ansible, Salt 都是比较好的配置管理工具&lt;/li&gt;
&lt;li&gt;Fabric 不是配置管理工具，如果你把它当作配置管理工具的话，会有你头疼的时候。你可以在 Fabric 的基础上
  构建你自己的配置管理工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;进程管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;系统默认的工具：upstart, systemd&lt;/li&gt;
&lt;li&gt;第三方软件：deamontools, supervisord, circus&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;更新代码&lt;/h4&gt;
&lt;p&gt;更新代码一般需要进行下面几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从版本控制服务器上拉取最新的代码&lt;/li&gt;
&lt;li&gt;更新依赖&lt;/li&gt;
&lt;li&gt;合并数据库更改(migrate)&lt;/li&gt;
&lt;li&gt;收集，压缩，推送静态文件到 CDN&lt;/li&gt;
&lt;li&gt;reload WSGI 服务器&lt;/li&gt;
&lt;li&gt;重启后台 workers&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐写个脚本自动执行这些操作，这样不容易出错。如果要更新多台服务器的话，可以使用远程执行
框架来做这种事情，比如： Salt, Fabric。&lt;/p&gt;
&lt;p&gt;有一点特别要注意的是，一旦服务上线就应该尽可能的使用平滑 reload 的方式来代替重启进程的暴力方式。&lt;/p&gt;
&lt;h4&gt;多个远程环境&lt;/h4&gt;
&lt;p&gt;至少要有两个环境吧：打包/开发环境，生产环境。
同时多个环境尽量保证一致性，尤其是多个生产环境之间（设置，软件，系统，等等）。
不过有些东西还行要区分的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方服务配置。比如，你肯定不希望在开发环境下触发支付操作或发送文件到生产环境下的 CDN 上。&lt;/li&gt;
&lt;li&gt;获取数据的问题。经常看到某些人在开发环境下使用线上数据库的副本，但是这里有几个问题要考虑：&lt;ul&gt;
&lt;li&gt;你的开发环境更生产环境一样安全吗？监控松散的开发机器是黑帽黑客经常会攻击的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有可能会从你的应用中发送邮件或通知吗？从你的开发环境下向你的用户发送数千封邮件不仅是非常
  尴尬的事情，同时也会影响你们的商业。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;避免单点故障&lt;/h4&gt;
&lt;p&gt;要经常备份，确保你知道所有存储的数据（数据库，用户上传的数据，等等）都有备份。这样出现故障的时候
其他其他机器的时候丢失的数据会少一点。&lt;/p&gt;
&lt;p&gt;高可用是一个可以考虑的方法，如果对你的商业来说他是非常重要的话。 HA 可以保证在出现服务挂掉
的情况下能够无缝自动切换到备用服务或者说不用手动切换。不过需要注意的是通常构建高可用
的花费比服务当掉的花费还高。&lt;/p&gt;
&lt;p&gt;在考虑架构的时候要考虑到如何解决单点故障的问题。举个例子，当使用第三方的 Amazon EC2 的时候，
你是否能够接受某些区域的设备宕机，整个地区呢？如果服务商 Amazone 当了怎么办？
越早考虑这些问题就能在灾难实际发生的时候更好的应对。&lt;/p&gt;
&lt;h3&gt;服务器布局&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡器： 可以使用云服务商提供的负载均衡服务或者使用 nginx, Haproxy。对于负载均衡器网络
  带宽是个非常重要的注意点。&lt;/li&gt;
&lt;li&gt;Web 加速器：网络带宽和内存是值得关注的点&lt;/li&gt;
&lt;li&gt;应用：CPU 和内存值得关注。&lt;/li&gt;
&lt;li&gt;后台运行的 workers：后台运行的任务通常都是 CPU 密集型的任务并且运行在独立的服务器上。一个服务器上可以运行
  多个 workers。&lt;/li&gt;
&lt;li&gt;缓存：你的缓存服务器需要更多的内存。另一个需要注意就是网络带宽，它可能会在内存之前成为瓶颈。如果网络开始
  拥堵的时候， Django 可以配置多个缓存服务器。&lt;/li&gt;
&lt;li&gt;数据库：足够的内存非常重要，最用是足够把你的数据都装载在内存里。
  如果你预期会有 64GB 的数据，那么至少要有 64GB 的内存。
  磁盘速度也非常重要。购买你能够负担得起的最快的磁盘。
  如果你用的是虚拟机的话，你需要留意你其实是在跟你的邻居共享一个物理磁盘，常规的实践是尽可能的买最大的虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优化技术栈&lt;/h3&gt;
&lt;h4&gt;优化数据库&lt;/h4&gt;
&lt;h4&gt;优化 uWSGI&lt;/h4&gt;
&lt;h4&gt;优化 Django&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;CACHES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用 Memcached，使用 pylibmc 这个库会有更高的性能。
redis 的话可以使用 &lt;a href="http://niwibe.github.io/django-redis"&gt;django-redis&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;缓存过期是第一个需要面临的问题，一个缓存 key 过期或者被刷新都有可能摧毁你的数据库。
幸运的是有个简单包可以解决这个问题： &lt;a href="https://github.com/joshourisman/django-newcache"&gt;django-newcache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一个问题就是如果缓存服务器宕机了会到期用户收到 “500 Server Error”的响应。
将使用一个缓存服务器改为三个可以降低出错的几率。
你需要考虑当缓存服务器宕机的时候，你是需要你的网站也跟着宕机，还是希望你的应用继续
运行良好只是把它当作缓存未命中来处理？作者创建了一个 &lt;a href="https://github.com/lincolnloop/django-ft-cache"&gt;django-ft-cache&lt;/a&gt; 包用来
解决这个问题，它会将任何的 memcached 操作用 try/except 包裹，捕获这里的异常，
这样缓存服务器当掉时请求依然可以被正确处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SESSION_ENGINE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把 session 保存在数据库中非常影响性能，一个好的办法是保存在缓存中。如果用 redis 的话
可以使用 cache backend, 用 memcached 的话 cached_db backend 也还行。
另一个办法就是使用 signed_cookies backend, 让客户端存储 session 数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATABASES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;DATABASES&lt;/code&gt; 设置增加 &lt;code&gt;CNN_MAX_AG&lt;/code&gt; key 选项来定义重用数据库连接。
比如 300, 这将告诉 Django 保持打开和重用数据库连接 5 分钟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOGGING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要定义 LOGGING 将日志保存到文件中，而是应该输出到 &lt;code&gt;STDERR&lt;/code&gt; ，让进程管理器来处理日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MIDDLEWARE_CLASSES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要轻易自定义中间件，因为中间件会在每个请求中执行。所以确保你知道每个中间件都做了什么，
以及尽可能的不要在中间件中执行数据库查询操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规安全问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意 clickjacking 和 XSS(Cross Site Scripting)。最简单的方法是使用
&lt;a href="https://github.com/carljm/django-secure#readme"&gt;django-secure&lt;/a&gt; 项目来检查安全问题。
另一个安全问题是，确保你的 admin 后台处于保护中，如果你把它开放出去了，确保使用了非常
复杂的管理员密码。最好是把它变成一个内网服务，让它不能从外部互联网访问。&lt;/p&gt;
&lt;h3&gt;配置你的服务器&lt;/h3&gt;
&lt;h4&gt;安全&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;调整 SSH 配置：禁用 &lt;code&gt;root&lt;/code&gt; 登录，禁用密码登录，更改默认端口。&lt;/li&gt;
&lt;li&gt;应用安全补丁：关注一下系统安全问题，及时更新 zer-day 补丁（比如，Hearbleed）&lt;/li&gt;
&lt;li&gt;使用私有网络：大多数云服务器都提供私有网络服务，只允许访问你帐号下的服务。在私有网络
  中访问你的服务器可以加大被人攻击你的难度。&lt;/li&gt;
&lt;li&gt;保护内网服务：内网服务包括控制台，开发服务器，持续集成系统。它们会成为你安全网络的一道暗门。
  将它们用 VPN 或认证代理锁起来，如果你没有使用 VPN 的话，确保传输数据以及登录时总是使用 SSL/HTTPS。
  锁住你的开发环境可以确保 google 不会抓取它从而伤害你的 SEO）&lt;/li&gt;
&lt;li&gt;防火墙：只允许指定端口和 IP 访问你的服务器。硬件防火墙很棒，软件防火墙比如 iptables 也不错。&lt;/li&gt;
&lt;li&gt;不要在 root 下运行：不在 root 下运行可以防止某些人运用 RCE(remote code execution)获取你服务器的
  root 访问权限。使用标准用户登录服务器，只在必要时使用 sudo。&lt;/li&gt;
&lt;li&gt;保护你的第三方服务的账户：使用强壮的密码，尽可能的开启两步验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;p&gt;对于数据库，有一个运行的 replica 可以很方便的执行全备份。推荐在半夜执行全备份。
进行备份的时候有几个问题需要问一下你自己：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有人黑进了你的服务器，他们能够删掉或破坏你的备份吗？
  基于这个原因拉取到备份服务器比推送要更好。&lt;/li&gt;
&lt;li&gt;如果有人拿到了你的备份会有多糟糕？加密备份文件并且确保黑客没法在同一个服务器上找到解密的方法（注：比如可以使用公钥进行加密，同时服务器上不要存有私钥，这样就不会被黑客在服务器上找到解密的方法）。&lt;/li&gt;
&lt;li&gt;你有测试过备份是否可用吗？定期测试你的备份，验证它们是否真的有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;监控&lt;/h3&gt;
&lt;p&gt;没有监控的话，线上网站就会成为一个大黑盒。你没法知道实际情况是怎样的，也就没法进行性能优化了。&lt;/p&gt;
&lt;h4&gt;instrumentation&lt;/h4&gt;
&lt;p&gt;对于应用，你需要知道下面这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的系统中最慢的部分是什么？&lt;/li&gt;
&lt;li&gt;Django 处理响应的平均耗时是多少？&lt;/li&gt;
&lt;li&gt;哪个视图是最慢的？或者花费最多的时间？&lt;/li&gt;
&lt;li&gt;哪个数据库查询是最慢的？或者花费最多的时间？&lt;/li&gt;
&lt;li&gt;这些数据一段时间内是如何变化的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://newrelic.com/"&gt;NewRelic&lt;/a&gt; 是个探测这些问题的比较好的服务，它可以很方便的安装。
然而， NewRelic 是闭源的，专有的系统，同时也非常的贵。有一些开源产品可以替代它。
比如：Graphite&lt;/p&gt;
&lt;h4&gt;服务器资源&lt;/h4&gt;
&lt;p&gt;关于服务器资源需要监控如下数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均负载&lt;/li&gt;
&lt;li&gt;CPU 负载&lt;/li&gt;
&lt;li&gt;物理内存使用情况&lt;/li&gt;
&lt;li&gt;磁盘相关数据&lt;/li&gt;
&lt;li&gt;网络 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;告警&lt;/h4&gt;
&lt;p&gt;下列情况需要发送告警：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超过 X% 的请求出现错误&lt;/li&gt;
&lt;li&gt;服务器宕机&lt;/li&gt;
&lt;li&gt;服务器资源占用过高：负载，虚拟内存，磁盘等等&lt;/li&gt;
&lt;li&gt;服务未响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;日志&lt;/h4&gt;
&lt;p&gt;需要收集如下日志：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从你的负载均衡器都应用的 Apache 风格的日志&lt;/li&gt;
&lt;li&gt;任何应用内的日志&lt;/li&gt;
&lt;li&gt;相关服务的 syslog 日志&lt;/li&gt;
&lt;li&gt;数据库慢查询日志，以及在不会导致数据库连接的 I/O 问题（尤其是磁盘或网络）的前提下收集所有数据库查询的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;错误汇报&lt;/h4&gt;
&lt;p&gt;在生成环境下 Django 默认会在出现异常时给网站管理员发送异常邮件。这个功能有时也会导致一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Email 不利于追踪错误&lt;/li&gt;
&lt;li&gt;如果你的错误发生在一个高访问的页面的话，你实际上是在 DoS 你的邮件服务器，
  可能导致被加入黑名单，或者你的邮件服务商会关掉你的服务（他们不想在几秒内发送超过 10K 的邮件）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，更好的错误汇报方式已经存在了，开源的 &lt;a href="https://www.getsentry.com/"&gt;Sentry&lt;/a&gt; 项目是个非常好的解决方案。
Sentry 并不会发送 10K 的邮件，它之后在第一次出现错误时邮件通知你，之后收集并在 Web 页面上
暂时其他时候的错误用于分析问题。&lt;/p&gt;
&lt;p&gt;还有一个关于错误的主题就是确保有一个漂亮的不引来应用服务的 500.html 文件，并且已经在服务器上配置好了出错是使用
这个页面。&lt;/p&gt;</summary><category term="High Performance Django"></category><category term="Django"></category></entry><entry><title>《High Performance Django》阅读笔记（一）</title><link href="https://mozillazg.com/2015/09/high-performance-django-note-1.html" rel="alternate"></link><updated>2015-09-26T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-09-26:2015/09/high-performance-django-note-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26359018/"&gt;&lt;img alt="" src="/static/images/reading/s28041145.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话点评：老司机的经验之谈，物有所值。&lt;/p&gt;
&lt;h2&gt;第一章：The Big Picture&lt;/h2&gt;
&lt;p&gt;作者开篇就提到大家总说 Django 性能不行，但是实际上
有很多高性能的站点是使用 Django 开发的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Django’s scaling success stories are almost too numerous to list at this point. It backs Disqus,
Instagram, and Pinterest. Want some more proof? Instagram was able to sustain over 30
million users on Django with only 3 engineers (2 of which had no back-end development
experience). Disqus serves over 8 billion page views per month. Those are some huge
numbers. These teams have proven Django most certainly does scale. Our experience here
at Lincoln Loop backs it up. We’ve built big Django sites capable of spending the day on
the Reddit homepage without breaking a sweat.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在作者的公司，他们开发高性能 Django 站点的准则就是 &lt;strong&gt;simplicity&lt;/strong&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using as few moving parts as possible to make it all work. “Moving parts” may be
servers, services or third-party software.&lt;/li&gt;
&lt;li&gt;Choosing proven and dependable moving parts instead of the new hotness.&lt;/li&gt;
&lt;li&gt;Using a proven and dependable architecture instead of blazing your own trail.&lt;/li&gt;
&lt;li&gt;Deflecting traffic away from complex parts and toward fast, scalable, and simple parts .&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Simple systems are easier to scale, easier to understand, and easier to develop. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构建高性能 Web 应用通常需要关注一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库。关系型数据库通常是整个技术栈中最慢最复杂的部分，一个办法是改用 NoSQL 数据库，不过
  大多数情况下都可以通过缓存解决。&lt;/li&gt;
&lt;li&gt;模板。我们可以用一个更快的模板引擎替换 Django 自带的模板引擎，不过即便是这样模板仍旧是
  整个技术栈中第二慢的部分。我们仍然可以通过缓存解决这个问题。&lt;/li&gt;
&lt;li&gt;Python。Python 在通常情况下已经足够快了。我们可以使用 Web 加速器（比如：Varnish）缓存服务器响应，
  在请求进入到 Python 那一层之前就返回相应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这章作者一直在强调缓存，"CACHE ALL THE THINGS"。无论你怎么优化你的技术栈，没有比缓存更快的优化方案。
说到缓存可能大家可能会顾虑缓存过期的问题，作者说了现在先别关心这个问题，之后会给出解决方案。&lt;/p&gt;
&lt;p&gt;作者提到一般的网站都保护这几层：负载均衡器，Web 加速器，APP 服务器，缓存，数据库。&lt;/p&gt;
&lt;p&gt;顺便提了一个 HTTPS 的负载均衡配置方法：客户端与负载均衡器之间使用 HTTPS，负载均衡器与后端服务之间使用 HTTP。这样既保证了安全又可以减少 HTTPS 对性能的影响。&lt;/p&gt;
&lt;h2&gt;第二章 The Build&lt;/h2&gt;
&lt;h3&gt;小技巧&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本地开发环境应该尽可能的与线上环境一致：相同的数据库，相同的操作系统以及相同的软件版本。。。&lt;/li&gt;
&lt;li&gt;组织 settings 文件，创建一个基础的配置文件 settings/base.py ，然后再为开发，测试，部署分别创建一个配置文件，一些重要的配置信息可以通过环境变量获取&lt;ul&gt;
&lt;li&gt;settings/base.py&lt;/li&gt;
&lt;li&gt;settings/dev.py&lt;/li&gt;
&lt;li&gt;settings/deploy.py&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里作者有提到一个小技巧，那就是环境变量的值都是字符串，那么如果将值转换为布尔值，元组甚至字典呢？答案就是可以使用 ast 模块:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &amp;gt;&amp;gt;&amp;gt; ast.literal_eval(&amp;#39;True&amp;#39;)
     True

    &amp;gt;&amp;gt;&amp;gt; ast.literal_eval(&amp;#39;1, 2, 3&amp;#39;)
     (1, 2, 3)

    &amp;gt;&amp;gt;&amp;gt; ast.literal_eval(&amp;#39;{&amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;}&amp;#39;)
     {&amp;#39;foo&amp;#39;: &amp;#39;bar&amp;#39;}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;小心第三方 APP&lt;/h3&gt;
&lt;p&gt;在决定使用某个第三方 APP 之前，先回答下面几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它真的符合你的需求吗？还是只是有点相近？&lt;/li&gt;
&lt;li&gt;它是个健康的项目吗？&lt;ul&gt;
&lt;li&gt;维护者有一个好的追踪记录吗？&lt;/li&gt;
&lt;li&gt;文档写的好吗？&lt;/li&gt;
&lt;li&gt;测试覆盖率够吗？&lt;/li&gt;
&lt;li&gt;社区怎样（贡献者，pull requests 等等）？&lt;/li&gt;
&lt;li&gt;还在处于活跃开发吗？&lt;/li&gt;
&lt;li&gt;有很多旧的 issues 和 pull requests 吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能咋样？&lt;ul&gt;
&lt;li&gt;它会产生多少数据库查询？&lt;/li&gt;
&lt;li&gt;易于缓存吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跟你项目的其他部分有冲突吗？&lt;/li&gt;
&lt;li&gt;它的授权协议跟你的项目兼容吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不再维护以及不稳定的第三方应用很快就会成为你的项目的负债。
可以尝试阅读源代码，然后从中找出你的项目需要的代码然后应用到项目中。&lt;/p&gt;
&lt;h3&gt;找出性能问题&lt;/h3&gt;
&lt;p&gt;可以使用下面这些工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://django-debug-toolbar.readthedocs.org/"&gt;Django Debug Toolbar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/recamshak/django-debug-panel"&gt;django-debug-panel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dcramer/django-devserver"&gt;django-devserver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;观察页面性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行了多少条 SQL 语句？&lt;/li&gt;
&lt;li&gt;有多少时间花费在数据库上？&lt;/li&gt;
&lt;li&gt;执行了什么特殊的查询操作，每次查询花费多长时间？&lt;/li&gt;
&lt;li&gt;这些查询是有什么代码生成的？&lt;/li&gt;
&lt;li&gt;渲染页面都用到了哪些模板？&lt;/li&gt;
&lt;li&gt;冷/热缓存是如果影响性能的？（提示：可以使用 settings 来切换缓存）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;哪里需要优化&lt;/h3&gt;
&lt;h4&gt;数据库优化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;减少查询次数&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;select_related&lt;/code&gt;, &lt;code&gt;prefetch_related&lt;/code&gt;, (提示：&lt;code&gt;prefetch_related&lt;/code&gt; 要放在查询的最后，不然会没有效果。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少查询时间&lt;ul&gt;
&lt;li&gt;不要忘记加索引（索引也是有代价的，每次对数据库进行写操作都需要更新索引）&lt;/li&gt;
&lt;li&gt;某些情况下 join 查询性能很差，在这种情况下两条查询语句比一条 join 耗时更少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限制结果数&lt;ul&gt;
&lt;li&gt;留意 &lt;code&gt;.all()&lt;/code&gt; 只取需要的结果数, &lt;code&gt;queryset[:20]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;count 查询很慢。可以的话，不要使用 count。比如使用 &lt;code&gt;.exists()&lt;/code&gt; 代替 count 进行判断记录是否存在。&lt;/li&gt;
&lt;li&gt;generic 外键。generic 外键是个很 cool 的功能，但是它会生成一些特别复杂的查询，所以可能的话，不要使用它。如果你一定要用的话，记得这是个需要缓存的地方。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化 model 方法。如果某个 model 方法在一个请求内会多次被调用，可以使用 &lt;code&gt;cache_property&lt;/code&gt; 缓存方法解决（缓存只在该请求内有效）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.utils.functional&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cached_property&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TheModel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="nd"&gt;@cached_property&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;expensive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
       &lt;span class="c1"&gt;# ...&lt;/span&gt;
       &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果太大了，包含了不需要的字段。使用 &lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;only&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, &lt;code&gt;values_list&lt;/code&gt; 限制结果大小:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;posts = Post.objects.all().defer(&amp;#39;body&amp;#39;)
posts = Post.objects.all().only(&amp;#39;title&amp;#39;)
posts = Post.objects.all().values(&amp;#39;id&amp;#39;)
posts = Post.objects.all().values_list(&amp;#39;id&amp;#39;)
posts = Post.objects.all().values_list(&amp;#39;id&amp;#39;, flat=True)
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存查询结果。这里提到两个库: &lt;a href="https://johnny-cache.readthedocs.org/en/latest/"&gt;Johnny Cache&lt;/a&gt; 和 &lt;a href="https://cache-machine.readthedocs.org/en/latest/"&gt;Cache Machine&lt;/a&gt; 这两个库的原理都是在 ORM 和数据库中间加了一个缓存层，将 ORM 生成的 SQL 作为 key 来缓存查询结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;只读 replicas。对那些读远远大于写的站点，可以考虑从 只读 replicas 中读取数据，实现读写分离。减少主库的负担优化性能。&lt;/li&gt;
&lt;li&gt;raw 查询。如果感觉 ORM 有点慢话，可以考虑使用 &lt;code&gt;raw&lt;/code&gt; 方法执行原生的 SQL 语句。&lt;/li&gt;
&lt;li&gt;反范式。这种方法有个问题就是每次更新的时候都需要同时更新其他表中相关的冗余字段。&lt;/li&gt;
&lt;li&gt;使用其他数据存储方式。比如： Postgres, redis, mongodb，使用 Elasticsearch 进行全文检索等。
  需要注意的是，在生产环境下新增一个服务并无法没有代价的。作为开发者我们可以不太在意这个，但是系统需要
  支持，配置，监控，备份等。新增服务的时候要考虑到这些代价以及你的系统管理员的意见。&lt;/li&gt;
&lt;li&gt;sharding。99.9% 的网站都不需要用到数据库的 sharding 功能，所以只有在你确信你遇到了那 0.1% 的时候
  再使用 sharding 功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;模板优化&lt;/h3&gt;
&lt;p&gt;应该缓存模板中一切可以缓存的东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;俄罗斯套娃式缓存。在一个模板里缓存嵌套缓存，就像俄罗斯套娃一样，一层套一层。比如:&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;{% cache MIDDLE_TTL &amp;quot;post_list&amp;quot; request.GET.page %}
    {% include &amp;quot;inc/post/header.html&amp;quot; %}
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;post-list&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    {% for post in post_list %}
        {% cache LONG_TTL &amp;quot;post_teaser_&amp;quot; post.id post.last_modified %}
            {% include &amp;quot;inc/post/teaser.html&amp;quot; %}
        {% endcache %}
    {% endfor %}
    &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endcache %}
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;自定义一个支持通过 url 参数刷新模板缓存的 cache 标签，这样就可以随时刷新缓存了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;随后处理耗时的任务&lt;/h3&gt;
&lt;p&gt;可以把耗时的，不需要同步知道结果的任务放到类似 celery 的任务队列中异步执行，
从而减少请求——响应的处理时间。下面这些任务可以考虑放到 celery 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方 API 的调用&lt;/li&gt;
&lt;li&gt;发邮件&lt;/li&gt;
&lt;li&gt;非常复杂的计算（视频处理，大量的数字处理等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于使用 celery 作者提到了一下小提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要将 model 实例作为任务的参数，可以改用传主键的方式。因为在这期间 model 的数据可能已经发生改变了，
  还有就是那个 model 实例可能不支持序列化。&lt;/li&gt;
&lt;li&gt;保持任务小，不要再一个任务中执行太多的工作。把一个任务分割成多个任务，一方面可以使用多核或多 worker 的
  方式加速任务执行，另一方面，单个任务可以很快的执行完方便安全快速的重启 worker，因为一个 worker 重启时
  会等待正在执行的问题完成，保持任务小巧的话，可以加快部署时间。&lt;/li&gt;
&lt;li&gt;可以考虑使用 celery 的 beat 功能去自习定时任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;前段优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;压缩 css 和 javascript（min, gzip, 版本化静态文件）。（个人建议：版本化文件应该类似这样 foo-xxyy.js 而不是这样 foo.js?v=xxyy ，主要是方便使用 CDN，防止出现缓存未过期的情况。）&lt;/li&gt;
&lt;li&gt;压缩图片。&lt;/li&gt;
&lt;li&gt;使用 CDN 服务静态文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文件上传&lt;/h3&gt;
&lt;p&gt;可以考虑使用分布式文件系统或者云存储来存储上传的文件。使用云存储的时候要考虑备用方案，万一服务不可用怎么办。&lt;/p&gt;
&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;好的测试用例是健康代码的强有力的基石。测试应该覆盖到你代码中最复杂，最重要，最容易出问题的地方。&lt;/p&gt;
&lt;h4&gt;自动化测试以及持续集成&lt;/h4&gt;
&lt;p&gt;一个持续集成系统可以让开发者在开发进度的早期就发现问题，通过持续集成系统来执行
自动化测试以及检查你的代码的健康度。作者提到了他们的检查点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;代码覆盖率&lt;/li&gt;
&lt;li&gt;PEP8/linting&lt;/li&gt;
&lt;li&gt;使用 Selenium 进行功能测试&lt;/li&gt;
&lt;li&gt;所以 Jmeter 进行性能测试&lt;/li&gt;
&lt;/ul&gt;</summary><category term="High Performance Django"></category><category term="Django"></category></entry><entry><title>《图解 HTTP》阅读笔记</title><link href="https://mozillazg.com/2015/08/tujie-http-note.html" rel="alternate"></link><updated>2015-08-28T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-08-28:2015/08/tujie-http-note.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/25863515/"&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/s27283822.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文记录了我阅读 《图解 HTTP》这本书时觉得重要的或之前不知道的内容。&lt;/p&gt;
&lt;h2&gt;了解 Web 及网络基础&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP 四层模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层：HTTP, FTP, DNS 协议之类的处于这一层&lt;/li&gt;
&lt;li&gt;传输层：提供两台计算机之间的数据传输，TCP, UDP 协议处于这一层&lt;/li&gt;
&lt;li&gt;网络层：处理在网络上流动的数据包，IP 协议处于这一层&lt;/li&gt;
&lt;li&gt;链路层（数据链路层）：处理网络的硬件部分：网卡，光纤等物理可见的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/1.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP 协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 ARP 协议凭借 MAC 地址进行通信&lt;/p&gt;
&lt;p&gt;ip -&amp;gt; mac1 -&amp;gt; mac2 -&amp;gt; mac3 -&amp;gt; mac&lt;/p&gt;
&lt;p&gt;ARP 协议（Address Resolution Protocol）是一种用以解析地址的协议，
根据通信方的 IP 地址就可以反查出对应的 MAC 地址。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/3.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我要给你发数据了 SYN (发送端） -&amp;gt; 回应一个收到 SYN + ACK（接收端） -&amp;gt; 回应一个 OK ACK （发送端）&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/4.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各协议与 HTTP 协议的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/5.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI 和 URL&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URI：统一资源标识符（Uniform Resource Identifier），比如：&lt;ul&gt;
&lt;li&gt;http://abc.com/a.txt&lt;/li&gt;
&lt;li&gt;redis://127.0.0.1/0&lt;/li&gt;
&lt;li&gt;mailto:foo@bar.com&lt;/li&gt;
&lt;li&gt;tel:+86123455&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;URL：统一资源定位符（Uniform Resource Locator）即我们熟悉的网址，比如：&lt;ul&gt;
&lt;li&gt;http://abc.com/a.txt&lt;/li&gt;
&lt;li&gt;https://foo.bar.com/foobar.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。
&lt;strong&gt;可见 URL 是 URI 的子集&lt;/strong&gt; 。&lt;/p&gt;
&lt;!--
## 简单的 HTTP 协议

## HTTP 报文内的 HTTP 信息

## 返回结果中的 HTTP 状态码
--&gt;

&lt;h2&gt;与 HTTP 协作的 Web 服务器&lt;/h2&gt;
&lt;p&gt;HTTP 通信时，处客户端和服务器外，还有一些用于通信数据转发的应用程序，例如：代理，网关和隧道。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的
  请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。&lt;ul&gt;
&lt;li&gt;缓存代理：代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。&lt;/li&gt;
&lt;li&gt;透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之，对
  报文内容进行加工的代理被成为非透明代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源
  的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。
  网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。&lt;/li&gt;
&lt;li&gt;隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;HTTP 首部&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;no-cache&lt;/code&gt;: 使用 no-cache 指令的目的是为了防止从缓存总返回过期的资源。
  事实上， no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认，然后再处理资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;no-store&lt;/code&gt;: 该指令规定缓存不能在本地存储请求或响应的任一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pragma&lt;/code&gt; 是 HTTP/1.1 之前版本的历史遗留字段。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Pargma: no-cache&lt;/code&gt;: 只能用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。
  但要整体掌握全部中间服务器使用 HTTP 协议版本确实不现实的。因此，发送的请求会同时含有
  &lt;code&gt;Cache-Control: no-cache&lt;/code&gt;和 &lt;code&gt;Pragma: no-cache&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;X-Frame-Options: 作用于 HTTP 响应，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。
  其主要目的是为了防止点击劫持（clickjacking）攻击。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DENY&lt;/code&gt;: 拒绝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SAMEORIGINE&lt;/code&gt;: 仅同源域名下的页面可以加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;X-XSS-Protection: 用于控制浏览器 XSS 防护机制的开关&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 将 XSS 过滤设置为无效状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;: 将 XSS 过滤设置为有效状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNT: 拒绝个人信息被收集&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 同意被追踪&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;: 拒绝被追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;协议中对 X- 前缀的废除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-, 来区分标准参数，并使
那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，
因此在 "RFC 6648 - Deprecating the "X-" Prefix and Similar
Constructs in Application Protocols" 中提议停止该做法。&lt;/p&gt;
&lt;p&gt;然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。&lt;/p&gt;
&lt;h2&gt;确保 HTTP 安全的 HTTPS&lt;/h2&gt;
&lt;p&gt;HTTP 协议的实现本是非常简单，不论是谁发送过来的请求都会返回响应，
因此不确认通信方，会存在以下各种隐患。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。
  有可能是已伪装的 Web 服务器。&lt;/li&gt;
&lt;li&gt;无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。&lt;/li&gt;
&lt;li&gt;无法确定正在通信的对方是否具有访问权限。因为某些 Web 服务器上保存着重要的信息，
  只想发给特定用户通信的权限。&lt;/li&gt;
&lt;li&gt;无法判定请求是来自何方、出自谁手。&lt;/li&gt;
&lt;li&gt;即时是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service, 拒绝服务器攻击）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP + 加密 + 认证 + 完整性包含 = HTTPS&lt;/p&gt;
&lt;p&gt;HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL(Secure Socket Layer) 和
TLS(Transport Layer Security)协议代替而已。&lt;/p&gt;
&lt;p&gt;通常， HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和
SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。
所以 HTTPS 又叫 HTTP over SSL, HTTP over TLS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称密钥加密&lt;/strong&gt;: 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system)，
也被叫做对称密钥加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;：公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称密钥。一把叫做私有密钥
(private key)，另一把叫做公开密钥（public key）。顾名思义，私有密钥
不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTPS 通信步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/6.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/7.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/8.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不一直使用 HTTPS&lt;/strong&gt; 既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗
  相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。&lt;/li&gt;
&lt;li&gt;除此之外，想要节约购买证书的开销也是原因之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基于 HTTP 的功能追加协议&lt;/h2&gt;
&lt;p&gt;HTTP 的瓶颈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条连接只可发送一个请求&lt;/li&gt;
&lt;li&gt;请求只能从客户端开始。客户端不可以接收除响应以外的指令&lt;/li&gt;
&lt;li&gt;请求/响应首部(header)未经压缩就发送。首部信息越多延迟越大。&lt;/li&gt;
&lt;li&gt;发送冗长的首部(header)。每次互相发送相同的首部造成的浪费较多。&lt;/li&gt;
&lt;li&gt;可任意选择数据压缩格式。非强制压缩发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SPDY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。
使用 SPDY 后，HTTP 协议额外获得以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多路复用流：通过单一的 TCP 请求，可以无限制处理多个 HTTP 请求。所有请求的处理
  都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。&lt;/li&gt;
&lt;li&gt;赋予请求优先级&lt;/li&gt;
&lt;li&gt;压缩 HTTP 首部(header)&lt;/li&gt;
&lt;li&gt;推送功能：支持服务器主动向客户端推送数据。&lt;/li&gt;
&lt;li&gt;服务器提示功能：服务器可以主动提示客户端请求所需的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/9.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用浏览器进行全双工的 WebSocket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有
的通信都依靠这个专用协议进行。 WebSocket 协议的主要特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推送功能&lt;/li&gt;
&lt;li&gt;减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/10.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;期盼已久的 HTTP/2.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下摘自： https://http2.github.io/faq/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What are the key differences to HTTP/1.x?&lt;/p&gt;
&lt;p&gt;At a high level, HTTP/2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is binary, instead of textual&lt;/li&gt;
&lt;li&gt;is fully multiplexed, instead of ordered and blocking&lt;/li&gt;
&lt;li&gt;can therefore use one connection for parallelism&lt;/li&gt;
&lt;li&gt;uses header compression to reduce overhead&lt;/li&gt;
&lt;li&gt;allows servers to “push” responses proactively into client caches&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Web 的攻击技术&lt;/h2&gt;
&lt;p&gt;因输出值转义不完全引发的安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨站脚本攻击（Cross-Site Scripting, XSS）&lt;/strong&gt; 主要是指在用户浏览器内运行了非法的 HTML 标签或 JavaScript 
  脚本。比如富文本编辑器，如果不过滤用户输入的数据直接显示用户输入的 HTML 内容的话，就会有可能运行恶意的 
  JavaScript 脚本，导致页面结构错乱，Cookies 信息被窃取等问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL 注入攻击（SQL Injection）&lt;/strong&gt; 是指针对 Web 应用使用的数据库，通过运行非法
  的 SQL 而产生的攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OS 命令注入攻击（OS Command Injection）&lt;/strong&gt; 是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。
  只要在能调用 Shell 函数的地方就有存在被攻击的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP 首部注入攻击（HTTP Header Injection）&lt;/strong&gt; 是指攻击者通过在响应首部字段内插入换行，添加任意响应首部
  或主体的一种攻击。属于被动工具模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP 响应截断攻击&lt;/strong&gt; 是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后
  发送。利用两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样
  就能显示伪造的主体，达到攻击的目的。这样的攻击叫做 HTTP 响应截断攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邮件首部注入攻击（Mail Header Injection）&lt;/strong&gt; 是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部
  To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或
  病毒邮件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录遍历攻击（Directory Traversal）&lt;/strong&gt; 是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问
  目的的一种攻击。比如，通过 ../ 等相对路径定位到 /etc/passwd 等绝对路径上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;远程文件包含漏洞（Remote File Inclusion）&lt;/strong&gt; 是指当部分脚本内容需要从其他文件读入是，攻击者利用指定外部服务器
  的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因设置或设计上的缺陷引发的安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强制浏览（Forced Browsing）安全漏洞&lt;/strong&gt; 是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开
  的文件。比如，没有对那些需要保护的静态资源增加权限控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不正确的错误消息处理（Error Handling Vulerability）的安全漏洞&lt;/strong&gt; 是指，Web 应用的错误信息内包含对攻击者有用
  的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放重定向（Open Redirect）&lt;/strong&gt; 是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，
  假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因会话管理疏忽引发的安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会话劫持（Session Hijiack）&lt;/strong&gt; 是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成
  用户，达到攻击的目的。&lt;/li&gt;
&lt;li&gt;对以窃取目标会话 ID 为主动攻击手段的会话劫持而言， &lt;strong&gt;会话固定攻击（Session Fixation）&lt;/strong&gt; 会强制用户使用攻击者指定
  的会话 ID，属于被动攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨站请求伪造（Cross-Site Request Forgeries, CSRF）攻击&lt;/strong&gt; 是指攻击者通过设置好陷阱，
  强制对已完成认证的用户进行非预期的个人信息或设定等某些状态更新，属于被动攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;密码破解&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点击劫持（Clickjacking）&lt;/strong&gt; 是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，
  单击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DoS 攻击（Denial of Service attack）&lt;/strong&gt; 是一种让运行中的服务呈停止状态的攻击。
  有时也叫做服务停止攻击或拒绝服务攻击。多台计算机发起的 Dos 攻击称为
  &lt;strong&gt;DDoS 攻击（Distributed Denial of Service attach）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后门程序（Backdoor）&lt;/strong&gt; 是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限的功能。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="HTTP"></category><category term="图解 HTTP"></category></entry></feed>